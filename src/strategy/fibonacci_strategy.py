"""
Fibonacci Retracement Trading Strategy
Implements fractal detection, swing analysis, and Fibonacci-based entry signals.
"""

import numpy as np
import pandas as pd
from typing import List, Dict, Tuple, Optional
from dataclasses import dataclass
import logging

logger = logging.getLogger(__name__)

@dataclass
class Fractal:
    """Represents a fractal (local high or low)."""
    timestamp: pd.Timestamp
    price: float
    fractal_type: str  # 'high' or 'low'
    bar_index: int

@dataclass
class Swing:
    """Represents a swing between two fractals."""
    start_fractal: Fractal
    end_fractal: Fractal
    direction: str  # 'up' or 'down'
    points: float  # Price difference
    bars: int      # Number of bars

@dataclass
class FibonacciLevel:
    """Fibonacci retracement level."""
    level: float    # 0.236, 0.382, 0.500, 0.618, 0.786
    price: float    # Actual price level
    hit: bool = False

@dataclass
class TradingSignal:
    """Trading signal generated by strategy."""
    timestamp: pd.Timestamp
    signal_type: str  # 'buy' or 'sell'
    price: float
    fibonacci_level: float
    swing_direction: str
    confidence: float
    stop_loss: float
    take_profit: float

class FibonacciStrategy:
    """
    Fibonacci Retracement Continuation Strategy
    
    Strategy Logic:
    1. Detect fractals (5-bar highs and lows)
    2. Identify swings between fractals
    3. Calculate Fibonacci retracement levels
    4. Generate signals when price retraces to key levels (38.2%, 50%, 61.8%)
    5. Trade in direction of dominant swing for continuation
    """
    
    def __init__(self, 
                 fractal_period: int = 5,
                 min_swing_points: float = 50.0,
                 fibonacci_levels: List[float] = None,
                 risk_reward_ratio: float = 2.0):
        """
        Initialize Fibonacci Strategy.
        
        Args:
            fractal_period: Number of bars to look back/forward for fractal detection
            min_swing_points: Minimum price movement to consider a valid swing
            fibonacci_levels: Fibonacci retracement levels to monitor
            risk_reward_ratio: Risk/reward ratio for trade management
        """
        self.fractal_period = fractal_period
        self.min_swing_points = min_swing_points
        self.fibonacci_levels = fibonacci_levels or [0.236, 0.382, 0.500, 0.618, 0.786]
        self.risk_reward_ratio = risk_reward_ratio
        
        # Strategy state
        self.fractals: List[Fractal] = []
        self.swings: List[Swing] = []
        self.fibonacci_zones: List[FibonacciLevel] = []
        self.signals: List[TradingSignal] = []
        
        # Current analysis state
        self.current_bar = 0
        self.dominant_trend = None  # 'up' or 'down'
        
    def detect_fractals(self, df: pd.DataFrame, current_index: int) -> Optional[Fractal]:
        """
        Detect fractal at specified index using 5-bar pattern.
        
        A fractal high: current high > 2 previous highs AND current high > 2 following highs
        A fractal low: current low < 2 previous lows AND current low < 2 following lows
        
        Args:
            df: OHLCV dataframe
            current_index: Index to check for fractal
            
        Returns:
            Fractal object if found, None otherwise
        """
        if current_index < self.fractal_period or current_index >= len(df) - self.fractal_period:
            return None
            
        current_high = df.iloc[current_index]['high']
        current_low = df.iloc[current_index]['low']
        
        # Check for fractal high
        is_fractal_high = True
        for i in range(1, self.fractal_period + 1):
            # Check previous bars
            if df.iloc[current_index - i]['high'] >= current_high:
                is_fractal_high = False
                break
            # Check following bars
            if df.iloc[current_index + i]['high'] >= current_high:
                is_fractal_high = False
                break
                
        # Check for fractal low
        is_fractal_low = True
        for i in range(1, self.fractal_period + 1):
            # Check previous bars
            if df.iloc[current_index - i]['low'] <= current_low:
                is_fractal_low = False
                break
            # Check following bars
            if df.iloc[current_index + i]['low'] <= current_low:
                is_fractal_low = False
                break
        
        # Create fractal object
        if is_fractal_high:
            return Fractal(
                timestamp=df.index[current_index],
                price=current_high,
                fractal_type='high',
                bar_index=current_index
            )
        elif is_fractal_low:
            return Fractal(
                timestamp=df.index[current_index],
                price=current_low,
                fractal_type='low',
                bar_index=current_index
            )
            
        return None
    
    def identify_swing(self, new_fractal: Fractal) -> Optional[Swing]:
        """
        Identify swing when new fractal is detected.
        Look for opposite fractal to create swing.
        """
        if not self.fractals:
            return None
            
        # Find the most recent opposite fractal
        opposite_type = 'low' if new_fractal.fractal_type == 'high' else 'high'
        
        for fractal in reversed(self.fractals):
            if fractal.fractal_type == opposite_type:
                # Calculate swing properties
                points = abs(new_fractal.price - fractal.price)
                bars = abs(new_fractal.bar_index - fractal.bar_index)
                
                # Check if swing meets minimum criteria
                if points >= self.min_swing_points:
                    direction = 'up' if new_fractal.fractal_type == 'high' else 'down'
                    
                    swing = Swing(
                        start_fractal=fractal,
                        end_fractal=new_fractal,
                        direction=direction,
                        points=points,
                        bars=bars
                    )
                    
                    return swing
                break
                
        return None
    
    def calculate_fibonacci_levels(self, swing: Swing) -> List[FibonacciLevel]:
        """
        Calculate Fibonacci retracement levels for a swing.
        """
        swing_high = max(swing.start_fractal.price, swing.end_fractal.price)
        swing_low = min(swing.start_fractal.price, swing.end_fractal.price)
        swing_range = swing_high - swing_low
        
        fib_levels = []
        for level in self.fibonacci_levels:
            if swing.direction == 'up':
                # For upswing, retracement levels below the high
                price = swing_high - (swing_range * level)
            else:
                # For downswing, retracement levels above the low  
                price = swing_low + (swing_range * level)
                
            fib_levels.append(FibonacciLevel(
                level=level,
                price=price,
                hit=False
            ))
            
        return fib_levels
    
    def generate_signal(self, df: pd.DataFrame, current_index: int, 
                       fib_level: FibonacciLevel, swing: Swing) -> Optional[TradingSignal]:
        """
        Generate trading signal when price hits Fibonacci level.
        """
        current_bar = df.iloc[current_index]
        current_price = current_bar['close']
        
        # Determine signal direction (trade in direction of swing for continuation)
        signal_type = 'buy' if swing.direction == 'up' else 'sell'
        
        # Calculate stop loss and take profit
        if signal_type == 'buy':
            # For buy signals, stop below recent low
            stop_loss = swing.start_fractal.price if swing.direction == 'up' else swing.end_fractal.price
            stop_loss *= 0.995  # Small buffer
            take_profit = current_price + (abs(current_price - stop_loss) * self.risk_reward_ratio)
        else:
            # For sell signals, stop above recent high
            stop_loss = swing.start_fractal.price if swing.direction == 'down' else swing.end_fractal.price
            stop_loss *= 1.005  # Small buffer
            take_profit = current_price - (abs(stop_loss - current_price) * self.risk_reward_ratio)
        
        # Calculate confidence based on Fibonacci level
        confidence_map = {0.382: 0.7, 0.500: 0.8, 0.618: 0.9}
        confidence = confidence_map.get(fib_level.level, 0.6)
        
        signal = TradingSignal(
            timestamp=df.index[current_index],
            signal_type=signal_type,
            price=current_price,
            fibonacci_level=fib_level.level,
            swing_direction=swing.direction,
            confidence=confidence,
            stop_loss=stop_loss,
            take_profit=take_profit
        )
        
        return signal
    
    def check_fibonacci_hits(self, df: pd.DataFrame, current_index: int) -> List[TradingSignal]:
        """
        Check if current price hits any active Fibonacci levels.
        """
        if not self.fibonacci_zones or not self.swings:
            return []
            
        current_bar = df.iloc[current_index]
        current_high = current_bar['high']
        current_low = current_bar['low']
        
        new_signals = []
        
        # Get the most recent swing for signal generation
        recent_swing = self.swings[-1]
        
        for fib_level in self.fibonacci_zones:
            if fib_level.hit:
                continue
                
            # Check if price touched this level
            if current_low <= fib_level.price <= current_high:
                fib_level.hit = True
                
                # Generate signal for key levels only
                if fib_level.level in [0.382, 0.500, 0.618]:
                    signal = self.generate_signal(df, current_index, fib_level, recent_swing)
                    if signal:
                        new_signals.append(signal)
                        
        return new_signals
    
    def process_bar(self, df: pd.DataFrame, current_index: int) -> Dict:
        """
        Process single bar and update strategy state.
        
        Returns:
            Dictionary with current analysis results
        """
        self.current_bar = current_index
        results = {
            'bar_index': current_index,
            'timestamp': df.index[current_index].isoformat(),
            'new_fractal': None,
            'new_swing': None,
            'new_signals': [],
            'fibonacci_levels': [],
            'total_fractals': len(self.fractals),
            'total_swings': len(self.swings),
            'total_signals': len(self.signals)
        }
        
        # 1. Check for new fractal (need future bars, so delay by fractal_period)
        if current_index >= self.fractal_period * 2:
            fractal_check_index = current_index - self.fractal_period
            new_fractal = self.detect_fractals(df, fractal_check_index)
            
            if new_fractal:
                self.fractals.append(new_fractal)
                results['new_fractal'] = {
                    'timestamp': new_fractal.timestamp.isoformat(),
                    'price': new_fractal.price,
                    'fractal_type': new_fractal.fractal_type,
                    'bar_index': new_fractal.bar_index
                }
                
                # 2. Check for new swing
                new_swing = self.identify_swing(new_fractal)
                if new_swing:
                    self.swings.append(new_swing)
                    results['new_swing'] = {
                        'start_fractal': {
                            'timestamp': new_swing.start_fractal.timestamp.isoformat(),
                            'price': new_swing.start_fractal.price,
                            'fractal_type': new_swing.start_fractal.fractal_type,
                            'bar_index': new_swing.start_fractal.bar_index
                        },
                        'end_fractal': {
                            'timestamp': new_swing.end_fractal.timestamp.isoformat(),
                            'price': new_swing.end_fractal.price,
                            'fractal_type': new_swing.end_fractal.fractal_type,
                            'bar_index': new_swing.end_fractal.bar_index
                        },
                        'direction': new_swing.direction,
                        'points': new_swing.points,
                        'bars': new_swing.bars
                    }
                    
                    # 3. Calculate new Fibonacci levels
                    self.fibonacci_zones = self.calculate_fibonacci_levels(new_swing)
                    results['fibonacci_levels'] = [
                        {
                            'level': fib.level,
                            'price': fib.price,
                            'hit': fib.hit
                        } for fib in self.fibonacci_zones
                    ]
        
        # 4. Check for Fibonacci level hits and generate signals
        new_signals = self.check_fibonacci_hits(df, current_index)
        if new_signals and len(new_signals) > 0:
            self.signals.extend(new_signals)
            results['new_signals'] = [
                {
                    'timestamp': signal.timestamp.isoformat(),
                    'signal_type': signal.signal_type,
                    'price': signal.price,
                    'fibonacci_level': signal.fibonacci_level,
                    'swing_direction': signal.swing_direction,
                    'confidence': signal.confidence,
                    'stop_loss': signal.stop_loss,
                    'take_profit': signal.take_profit
                } for signal in new_signals if signal is not None
            ]
        else:
            results['new_signals'] = []
        
        results['total_fractals'] = len(self.fractals)
        results['total_swings'] = len(self.swings) 
        results['total_signals'] = len(self.signals)
        
        return results
    
    def reset(self):
        """Reset strategy state for new backtest."""
        self.fractals.clear()
        self.swings.clear()
        self.fibonacci_zones.clear()
        self.signals.clear()
        self.current_bar = 0
        self.dominant_trend = None
    
    def get_current_state(self) -> Dict:
        """Get current strategy state for dashboard display."""
        return {
            'fractals': [
                {
                    'timestamp': f.timestamp.isoformat(),
                    'price': f.price,
                    'type': f.fractal_type,
                    'bar_index': f.bar_index
                } for f in self.fractals
            ],
            'swings': [
                {
                    'start_timestamp': s.start_fractal.timestamp.isoformat(),
                    'end_timestamp': s.end_fractal.timestamp.isoformat(),
                    'start_price': s.start_fractal.price,
                    'end_price': s.end_fractal.price,
                    'direction': s.direction,
                    'points': s.points,
                    'bars': s.bars
                } for s in self.swings
            ],
            'fibonacci_levels': [
                {
                    'level': f.level,
                    'price': f.price,
                    'hit': f.hit
                } for f in self.fibonacci_zones
            ],
            'signals': [
                {
                    'timestamp': s.timestamp.isoformat(),
                    'type': s.signal_type,
                    'price': s.price,
                    'fibonacci_level': s.fibonacci_level,
                    'swing_direction': s.swing_direction,
                    'confidence': s.confidence,
                    'stop_loss': s.stop_loss,
                    'take_profit': s.take_profit
                } for s in self.signals
            ]
        }